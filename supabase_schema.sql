-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- ==========================================
-- 1. Helper Functions (Prevent Recursion)
-- ==========================================

-- Function to check membership safely (bypasses RLS)
create or replace function public.is_ledger_member(_ledger_id uuid)
returns boolean as $$
begin
  return exists (
    select 1
    from public.ledger_members
    where ledger_id = _ledger_id
    and user_id = auth.uid()
  );
end;
$$ language plpgsql security definer;

-- Function to check role safely (bypasses RLS)
create or replace function public.get_my_role(_ledger_id uuid)
returns text as $$
declare
  _role text;
begin
  select role into _role
  from public.ledger_members
  where ledger_id = _ledger_id
  and user_id = auth.uid();
  return _role;
end;
$$ language plpgsql security definer;

-- ==========================================
-- 2. Tables & Schema
-- ==========================================

-- Profiles
create table if not exists public.profiles (
  id uuid references auth.users on delete cascade primary key,
  email text unique not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
alter table public.profiles enable row level security;

-- Ledgers
create table if not exists public.ledgers (
  id uuid default uuid_generate_v4() primary key,
  name text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  created_by uuid references auth.users not null
);
alter table public.ledgers enable row level security;

-- Ledger Members
create table if not exists public.ledger_members (
  id uuid default uuid_generate_v4() primary key,
  ledger_id uuid references public.ledgers on delete cascade not null,
  user_id uuid references auth.users on delete cascade not null,
  role text default 'member' check (role in ('owner', 'admin', 'member')),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(ledger_id, user_id)
);
alter table public.ledger_members enable row level security;

-- Transactions (Ensure ledger_id exists)
create table if not exists public.transactions (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  amount numeric not null,
  type text not null check (type in ('income', 'expense')),
  category text not null,
  date date not null default current_date,
  note text,
  user_id uuid references auth.users not null
);
alter table public.transactions enable row level security;

-- Add ledger_id column if it doesn't exist (idempotent)
do $$
begin
    if not exists (select 1 from information_schema.columns where table_name = 'transactions' and column_name = 'ledger_id') then
        alter table public.transactions add column ledger_id uuid references public.ledgers on delete cascade;
    end if;
end $$;

-- ==========================================
-- 3. RLS Policies
-- ==========================================

-- Profiles
drop policy if exists "Public profiles are viewable by everyone" on public.profiles;
create policy "Public profiles are viewable by everyone" on public.profiles for select using ( true );

drop policy if exists "Users can insert their own profile" on public.profiles;
create policy "Users can insert their own profile" on public.profiles for insert with check ( auth.uid() = id );

drop policy if exists "Users can update own profile" on public.profiles;
create policy "Users can update own profile" on public.profiles for update using ( auth.uid() = id );

-- Ledgers
drop policy if exists "Users can view ledgers they belong to" on public.ledgers;
create policy "Users can view ledgers they belong to" on public.ledgers for select
  using ( 
    public.is_ledger_member(id) 
    OR 
    created_by = auth.uid() -- Allow creator to see it immediately (crucial for rpc/inserts)
  );

drop policy if exists "Users can create ledgers" on public.ledgers;
create policy "Users can create ledgers" on public.ledgers for insert with check ( auth.uid() = created_by );

drop policy if exists "Users can update ledgers they admin" on public.ledgers;
create policy "Users can update ledgers they admin" on public.ledgers for update
  using ( public.get_my_role(id) in ('owner', 'admin') );

-- Ledger Members
drop policy if exists "Members can view other members" on public.ledger_members;
create policy "Members can view other members" on public.ledger_members for select
  using (
    user_id = auth.uid() 
    OR
    public.is_ledger_member(ledger_id)
  );

drop policy if exists "Owners can add members" on public.ledger_members;
create policy "Owners can add members" on public.ledger_members for insert
  with check (
    public.get_my_role(ledger_id) in ('owner', 'admin')
    OR
    -- Allow initial owner insertion
    (
      not exists (select 1 from public.ledger_members where ledger_id = public.ledger_members.ledger_id)
      and
      exists (select 1 from public.ledgers where id = public.ledger_members.ledger_id and created_by = auth.uid())
    )
  );

-- Transactions
drop policy if exists "Users can view their own transactions" on public.transactions;
drop policy if exists "Users can insert their own transactions" on public.transactions;
drop policy if exists "Users can update their own transactions" on public.transactions;
drop policy if exists "Users can delete their own transactions" on public.transactions;

drop policy if exists "Users can view transactions from their ledgers" on public.transactions;
create policy "Users can view transactions from their ledgers" on public.transactions for select
  using ( public.is_ledger_member(ledger_id) );

drop policy if exists "Users can insert transactions into their ledgers" on public.transactions;
create policy "Users can insert transactions into their ledgers" on public.transactions for insert
  with check ( public.is_ledger_member(ledger_id) );

drop policy if exists "Users can update transactions in their ledgers" on public.transactions;
create policy "Users can update transactions in their ledgers" on public.transactions for update
  using ( public.is_ledger_member(ledger_id) );

drop policy if exists "Users can delete transactions in their ledgers" on public.transactions;
create policy "Users can delete transactions in their ledgers" on public.transactions for delete
  using ( public.is_ledger_member(ledger_id) );


-- ==========================================
-- 4. Triggers & RPCs
-- ==========================================

-- Profile Creation Trigger
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email)
  values (new.id, new.email)
  on conflict (id) do nothing;
  return new;
end;
$$ language plpgsql security definer;

drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Atomic Ledger Creation RPC
-- Drop old signature if exists to allow cleaner rename
drop function if exists public.create_ledger(text);

create or replace function public.create_ledger(new_ledger_name text)
returns json as $$
declare
  new_ledger_id uuid;
  new_ledger_record record;
begin
  -- 1. Insert Ledger
  insert into public.ledgers (name, created_by)
  values (new_ledger_name, auth.uid())
  returning id, name, created_at, created_by into new_ledger_record;
  
  new_ledger_id := new_ledger_record.id;

  -- 2. Insert Member (Owner)
  insert into public.ledger_members (ledger_id, user_id, role)
  values (new_ledger_id, auth.uid(), 'owner');

  return row_to_json(new_ledger_record);
end;
$$ language plpgsql security definer;
